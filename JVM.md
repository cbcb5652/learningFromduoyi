# JVM

> - 请你谈谈你对JVM的理解？java8的虚拟机有什么更新？
> - 什么是OOM？什么是StackOverflowError？有哪些方法分析？
> - JVM常用的参数调优你知道哪些？
> - 谈谈JVM中，对类加载器你的认识？

**遇到的问题**

> - 运行着的线上系统突然卡死，系统无法访问，甚至直接OOM！
> - 想解决线上的JVM GC问题，但却无从下手
> - 新项目上线，对各种JVM参数设置一脸茫然，直接默认吧，然后就GG
> - 每次面试前都要背一遍JVM的一些原理，但是还是理解不了，一被问到调优JVM，解决GC，OOM等问题 一脸懵

**为什么要学习JVM**

> - 面试的需要(BATJ  TMD  PKQ等面试都爱问)
> - 中高级程序原必备技能
>   - 项目管理，调优的需要
> - 追求极客的精神
>   - 比如：垃圾回收算法，JIT，底层原理

**JVM所处的位置**

![image-20201222121508450](images/image-20201222121508450.png)

**Java代码的执行流程**

![image-20201222134052737](images/image-20201222134052737.png)

JIT编译器是负责将坚持执行的代码编译，提高运行效率的。

**JVM的声明周期**

- 虚拟机的启动

Java虚拟机的启动是通过引导类加载器(bootstartp class loader) 创建一个初始类(inital class)来完成的，这个类是由虚拟机的具体实现指定的。

- 虚拟机的执行
  - 一个运行中的Java虚拟机有着一个清晰的任务；执行Java程序
  - 程序开始执行时他才开始运行，程序结束时他就停止
  - ==执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。==（程序在执行中的话使用jps是可以看到正在执行的线程的）

**虚拟机的退出**

- 程序的正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致Java虚拟机进程终止
- 某线程调用Runtime类（单例，饿汉式）或System类的exit方法 或 Runtime类的halt方法，并且Java安全管理器允许这次exit或halt操作



## 内存与垃圾回收

### JVM的发展历程

####  Sun Classic VM

- 早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。
- 这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。
- 如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。
- 现在hotspot内置了此虚拟机。

####  Exact VM

为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。 Exact Memory Management：准确式内存管理

- 也可以叫Non-Conservative/Accurate Memory Management
- 虚拟机可以知道内存中某个位置的数据具体是什么类型。|

具备现代高性能虚拟机的维形

- 热点探测（寻找出热点代码进行缓存）
- 编译器与解释器混合工作模式

只在solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换

#### HotSpot VM

HotSpot历史

- 最初由一家名为“Longview Technologies”的小公司设计
- 1997年，此公司被sun收购；2009年，Sun公司被甲骨文收购。
- JDK1.3时，HotSpot VM成为默认虚拟机

目前Hotspot占有绝对的市场地位，称霸武林。

- 不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot
- Sun/oracle JDK和openJDK的默认虚拟机
- 因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的Gc机制。（比如其他两个商用虚机都没有方法区的概念）

从服务器、桌面到移动端、嵌入式都有应用。

名称中的HotSpot指的就是它的热点代码探测技术。

- 通过计数器找到最具编译价值代码，触发即时编译或栈上替换
- 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡

####  Jockit

专注于服务器端应用

- 它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。

大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。

- 使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。

优势：全面的Java运行时解决方案组合

- JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要
- MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。

2008年，JRockit被oracle收购。

oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。

高斯林：目前就职于谷歌，研究人工智能和水下机器人

####  IBM的J9

全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9

市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。

目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。

2017年左右，IBM发布了开源J9VM，命名为openJ9，交给EClipse基金会管理，也称为Eclipse OpenJ9

OpenJDK -> 是JDK开源了，包括了虚拟机

####  KVM和CDC / CLDC Hotspot

oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Angroid和ioS二分天下。

KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场

- 智能控制器、传感器
- 老人手机、经济欠发达地区的功能手机

所有的虚拟机的原则：一次编译，到处运行。

####  Azul VM

前面三大“高性能Java虚拟机”使用在通用硬件平台上这里Azu1VW和BEALiquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机I

- 高性能Java虚拟机中的战斗机。

Azul VM是Azu1Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的ava虚拟机。

每个Azu1VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。

2010年，AzulSystems公司开始从硬件转向软件，发布了自己的zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。

####  Liquid VM

高性能Java虚拟机中的战斗机。

BEA公司开发的，直接运行在自家Hypervisor系统上Liquid VM即是现在的JRockit VE（Virtual Edition），

Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。

随着JRockit虚拟机终止开发，Liquid vM项目也停止了。

#### Apache Marmony

Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。

它是IElf和Inte1联合开发的开源JVM，受到同样开源的openJDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK

虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。

#### Micorsoft JVM

微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。

只能在window平台下运行。但确是当时Windows下性能最好的Java VM。

1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软windowsXPSP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。

#### Taobao JVM

由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。

基于openJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。

基于openJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。

- 创新的GCIH（GCinvisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且Gc不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升Gc的回收效率的目的。
- GCIH中的对象还能够在多个Java虚拟机进程中实现共享
- 使用crc32指令实现JvM intrinsic降低JNI的调用开销
- PMU hardware的Java profiling tool和诊断协助功能
- 针对大数据场景的ZenGc

taobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能

目前已经在淘宝、天猫上线，把oracle官方JvM版本全部替换了。

#### Dalvik VM

谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。

Dalvik y只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范

不能直接执行Java的Class文件

基于寄存器架构，不是jvm的栈架构。

执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。

- 它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。

Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。

#### Graal VM

2018年4月，oracle Labs公开了GraalvM，号称 "Run Programs Faster Anywhere"，勃勃野心。与1995年java的”write once，run anywhere"遥相呼应。

GraalVM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等

支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件

工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。

如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。





### 类加载器(ClassLoader)

> 负责加载class文件，class文件在文件开头有特定的文件标识（cafe babe），将class文件字节码内容加载到内存中，并将这些文件内容转换成方法区中的运行时数据结构并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定

- 第一步user.class 文件被ClassLoader加载，变成了user   Class  进入了方法区，相当于8锁那边的模板 static静态方法

**加载器**

- 启动类加载器(Bootstarp) C++
- 扩展类加载器(Extension)  Java
- 应用程序类加载器(AppClassLoader)

一些java自带的类，由类加载器 初始化加载，放在jre/lib/rt.jar 包中（根加载器）

扩展包的加载由扩展类加载器加载，也就是lib包下面的jar包

自己定义的方法类 是由应用程序类加载器加载的

Object.getClass().getClassLoader();  -->  获取类加载器

![image-20201222100225394](images/image-20201222100225394.png)

#### Bootstarp ClassLoader( 启动类加载器)

- 这个类加载使用C/C++实现，嵌套在JVM内部
- 它用来加载Java的核心库(JAVA_HOME/jre/lib/rt.jar,resouces.jar,sun.boot.path路径下的内容)，用于提供JVM自身需要
- 并不继承自java.lang.ClassLoader,没有父加载器
- 加载扩展类和应用程序类加载器，并指定为他们的父类加载器
- 处于安全考虑, bootstarp启动类加载器只加载包名为java,javax,sun 等开头的类

![image-20201222183109739](images/image-20201222183109739.png)



#### 扩展类加载器

- Java语言编写，由sun.misc.Launcher$ExtClassLoader实现
- 派生于ClassLoader类
- 父类加载器为启动类加载器
- 从java.ext.dirs 系统属性所指定的目录中加载类库，或从JDK的安装目录的 jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。



#### 应用程序类加载器 （AppClassLoader）

- java语言编写，由sun.misc.Laucher$AppClassLoder实现
- 派生于Classloader类
- 父类加载器为扩展类加载器
- 它负责加载环境变量classpath或系统属性，java.class.path 指定路径下的类库
- 该类加载是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载
- 通过ClassLoader#getSystemClassLoader() 方法可以获取到该类加载器

----

#### 用户自定义的类加载器

- 在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器互相配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。
- 隔离加载类
- 修改类加载的方式
- 扩展加载源
- 防止源码泄露

**实现步骤:**

1. 开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的要求
2. 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoder类并重写loadClass() 方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass() 方法，而是建议把自定义的类加载逻辑写在findClass() 方法中
3. 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass() 方法及其获取字节码流的方式，使用自定义类加载器编写更加简洁。

**获取类加载器**

```java
package jvm.test;
// 获取类加载器
public class ClassLoaderTest1 {
    public static void main(String[] args) throws ClassNotFoundException {
        ClassLoader classLoader = Class.forName("java.lang.String").getClassLoader();
        System.out.println(classLoader);

        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        System.out.println(contextClassLoader);

        ClassLoader classLoader1 = ClassLoader.getSystemClassLoader().getParent();
        System.out.println(classLoader1);
    }
}
```





### 类加载过程

> 类加载:
>
> - 通过一个类的全限定名获取定义此类的二进制字节流
> - 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
> - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

**类加载子系统**



![image-20201222170338560](images/image-20201222170338560.png)

**子系统部分**

![image-20201222170547264](images/image-20201222170547264.png)

作用：

- 类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识
- ClassLoader只负责class文件的加载，至于它是否可运行，则由Execution Engine决定
- 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常亮量信息是Class文件中常量池部分的内存映射）

**类加载过程**

![image-20201222173501820](images/image-20201222173501820.png)

**初始化：**

- 初始化阶段就是执行类构造器方法<clinit>()  的过程
- 此方法不用编译，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来的
- 构造器方法中指令按语句在源文件中出现的顺序执行
- <clinit>() 不同于类的构造器。(关联：构造器是虚拟机视角下<init>())
- 若该类具有父类，JVM会保证子类的<clinit>() 执行之前，父类的<clinit>() 已经执行完成。

```java
package jvm.test;

public class ClassInitTest {

    private static int num = 1;

    static {
        num = 2;
        number = 20;
    }

    private static int number = 10;   // prepre 阶段已经给number 赋默认值0;

    public static void main(String[] args) {
        System.out.println(ClassInitTest.num);      // 2
        System.out.println(ClassInitTest.number);   // 10
    }
}
```





### 双亲委派

![image-20201222195620583](images/image-20201222195620583.png)



> **作用：** 保证java源代码不受污染，保证源码干净（==沙箱安全==）

当一个类收到类加载请求，他首先不会去加载这个类，而是把这个请求委派给父类去完成，每一个层次加载器都是如此，因此所有的加载请求都应该传达到启动类加载器中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。

采用双亲委派的一个好处是比如 加载位于rt.jar 包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同一个Object对象。

如： 新建一个包 java.lang  ---> 类 String 无法启动main方法

```java
package jvm.java.lang;
public class String {
    // 运行不了！！！
    public static void main(String[] args) {
        System.out.println("hello world!");
    }
}
```

因为类在加载的时候 默认去bootstarp类加载器 最顶层上面找，发现有这个类的时候 不会加载 当前自己的类，保证了源代码不会被污染。

==如果想自己定义类加载器  直接继承ClassLoader 就行了==

类方法内部 可以编写只有声明的类，不需要实现，但是这个方法只作为声明，不被java调用，只能由C语言或者其他语言调用，加了Native的意思是java已经无法调用了，只能交由其他语言调用，只是声明了接口、（加了Navtive的方法都走 本地方法栈）	



### 理解执行引擎

**翻译机**

> 包括了解释器和JIT

- 解释器： 需要进行逐行解释，  类似于走路，虽然没停，但是比较慢
- JIT：  提供方法区的CodeCache缓冲，类似于公交车，需要等待一段时间后，才能快速行驶



### 类的主动使用与被动使用

> 每个类或者接口只有在首次主动使用时才初始化他们

#### 主动使用七种情况

- 创建类的实例
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射(比如： Class.forName("java.lang.String"))
- 初始化一个类的子类
- Java虚拟机启动时被标明为启动类的类
- JDK7 开始提供的动态语言支持：
  - java.lang.invoke.MethodHandle 实例的解析结果
  - REF_getStatic, REF_putStatic, REF_invokeStatic 句柄对应的类没有初始化，则初始化
- 除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化



### 程序计数器（PC寄存器）

> PC寄存器是用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。

![image-20201222203103416](images/image-20201222203103416.png)

**介绍**

-  是一块很小的内存空间，几乎可以不计，也是运行速度最快的存储区域
- 每个线程都有自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致
- 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址：或者，如果是在执行native方法，则是未指定的值
- 是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个程序计数器来完成
- 字节码解释器工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
- 它是唯一一个在Java 虚拟机规范中没有规定任何OutofMemoryError情况的区域。 （即没有GC也没有OOM）

![image-20201222204626609](images/image-20201222204626609.png)

> 使用PC寄存器存储字节码指令地址有什么用呢？

因为CPU在不停的切换线程，这个时候切换回来我们需要知道，从哪继续开始。



> 为什么使用PC寄存器来记录当前的执行地址呢？

JVM字节码解释器就需要通过改变PC寄存器的值来明确下一个该执行什么样的字节码指令。



> PC寄存器为什么是线程私有的呢？

![image-20201222205110858](images/image-20201222205110858.png)



### 虚拟机栈

**目录结构:**

> - 虚拟机栈的概述
> - 栈从存储单位
> - 局部变量表
> - 操作数栈
> - 代码追踪
> - 栈顶缓存技术
> - 动态链接
> - 方法的调用：解析与分派
> - 方法返回地址
> - 一些附加信息
> - 栈的相关面试题

#### 概述

==栈是运行的单位，而堆是存储的单位==

栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。

堆解决的是数据存储的问题，即数据怎么存放，放在哪

> Java虚拟机栈是什么?

每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈贞，对应着一次次的java调用方法。  （是线程私有的）

- 生命周期：   生命周期与线程一致
- 作用： 主管Java程序的运行，它保存方法的局部变量，部分结果，并参与方法的调用和返回。

![image-20201222211432414](images/image-20201222211432414.png)

**栈的优点：**

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
- JVM直接对Java栈的操作只有两个：
  - 每个方法执行，伴随着进栈（入栈，压栈）
  - 执行结束后的出栈工作
- 对于栈来说不存在垃圾回收问题
  - GC ； OOM

**开发中遇到的异常有哪些？**

![image-20201222212023746](images/image-20201222212023746.png)

**栈存储什么？**

- 每个线程都有自己的栈，栈中的数据都是以栈贞的格式存在
- 在这个线程上执行的每个方法都各自对应一个栈贞（Stack Frame）
- 栈贞是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息

#### 栈帧的内部结构

**每个栈帧存储着：**

- ==局部变量表==
- ==操作数栈==
- 动态链接 （或指向运行时常量池的方法引用）
- 方法返回地址  （或方法正常退出或者异常的定义）
- 一些附加信息

**帧数据区：** 附加信息 + 动态链接 + 方法返回地址



<img src="images/image-20201224204631128.png" alt="image-20201224204631128" style="zoom:80%;" />

-------

**局部变量表：**

> 被称为局部变量数组或本地变量表
>
> - 主要存储方法参数和定义在方法体内的局部变量  类型(基本数据类型，对象引用，returnAddress)
> - 存放着预编译期可知的各种基本数据类型（8种），引用类型，returnAddress类型
> - 32位以内的类型只占用一个slot，64位的类型（long/double）只占用两个slot

![image-20201224205504183](images/image-20201224205504183.png)

#### 操作数栈

> 栈：可以使用数组/ 链表来实现  ==操作数栈是用数组实现的==
>
> 操作数栈：主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。

![image-20201228203847468](images/image-20201228203847468.png)

局部变量表和操作数栈： 将局部变量表的数据，放到操作数栈计算之后，再放回局部变量表。

**栈顶缓存技术**

> 将栈顶元素全部缓存在物理CPI的寄存器中，以次降低对内存的读/ 写次数，提升执行引擎的执行效率。

----

#### 动态链接

- 每一个栈帧内部都包含着一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了让当前代码能够实现动态链接
- 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么==动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用==

![image-20201229101935686](images/image-20201229101935686.png)



> 为什么不直接把方法放在栈帧部分（动态链接）？

因为多个方法可能引用同一个对象，如果使用引用的话，不需要每个方法都声明，只需要定义一样的引用地址就能调用到相同的方法了。（直接指向就行了）

> 为什么需要常量池呢？

常量池的作用，就是为了提供一些符号和常量，便于指令的识别。

------

#### 方法的调用

> 在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关

- 静态链接
  - 当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译器可知，且运行期保持不变时。这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接。
  - 早期绑定
- 动态链接
  - 如果被调用的方法在编译期间无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接
  - 晚期绑定

**虚方法与非虚方法**

- 非虚方法
  - 如果方法在编译期就确定了的具体调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法
  - 静态方法，私有方法，final方法，实例构造器，父类方法都是非虚方法
  - 其他方法称为虚方法

![image-20201229104918789](images/image-20201229104918789.png)

**动态类型语言和静态类型语言**

#### 方法返回地址

![image-20201229111650168](images/image-20201229111650168.png)

- 一个方法的结束，有两种方式：
  - 正常执行完成
  - 出现未处理异常，非正常退出
- 物理通过哪种方式退出，在方法退出后返回到该方法被调用的位置。方法正常退出时，==调用者的pc计数器值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。

**异常处理**

在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异地表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。

方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。

![image-20201229112857072](images/image-20201229112857072.png)

本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层的方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置PC寄存器值，让调用者方法继续执行下去。

==正常完成调用和异常完成调用的区别在于：通过异常完成的出口退出的不会给他的上层调用者产生任何的返回值==

#### 栈的相关面试题

> 举例栈溢出的情况？(StackOverflowError)

- 通过-Xss 设置栈的大小：OOM



> 调整栈大小，就能保证不出现溢出吗？

不能，只能让StackOverflowError出现得更久。



> 分配的栈内存越大越好吗？

会限制到创建的线程数等，而且当栈出现溢出的时候，扩大栈的内存，只能延缓溢出的时间，而不能解决本质问题。



> 垃圾回收是否会涉及到虚拟机栈？

不会的！



> 方法中定义的局部变量是否线程安全？

**具体问题具体分析**

```java
package jvm.test;

public class StringBuilderTest {

    int num = 10;

    // s1 的声明是线程安全的
    public static void method1(){
        //stringBuilder： 线程不安全
        StringBuilder s1 = new StringBuilder();
        s1.append("a");
        s1.append("b");
    }

    //stringBuilder：是线程不安全的
    public static void method2(StringBuilder stringBuilder){
        stringBuilder.append("a");
        stringBuilder.append("b");
    }

    //s1的操作: 是线程不安全的
    public static StringBuilder method3(){
        StringBuilder s1 = new StringBuilder();
        s1.append("a");
        s1.append("b");
        return s1;
    }

    //s1的操作：是线程安全的
    public static String method4(){
        StringBuilder s1 = new StringBuilder();
        s1.append("a");
        s1.append("b");
        return s1.toString();
    }
}
```

### 本地方法栈

> - Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用
> - 本地方法栈，也是现场私有的
> - 运行被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）
> - 本地方法是使用C语言实现的
> - 它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库

![image-20201229135950657](images/image-20201229135950657.png)











### 本地方法接口Native

**为什么要使用Native Method？**

Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。

- 与Java环境外的交互
  - 有时候Java应用需要与外部的环境交互，这是本地方法存在的主要原因。本地方法提供一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。
- 与操作系统的交互
  - 通过使用本地方法，我们得以用Java实现了jre与底层系统的交互，甚至JVM的一些部分就是用C写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。
- Sun's Java
  - Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的。它也通过一些本地方法与外界交互。

### 堆

> - 堆的核心概述
> - 设置堆的大小与OOM
> - 新生代与老年代
> - 图解对象分配过程
> - Minor GC，Major GC，Full GC
> - 堆空间分代思想
> - 内存分配策略
> - 为对象分配内存：TLAB
> - 小结堆空间的参数设置
> - 堆是分配对象的唯一选择吗

![image-20201229142608788](images/image-20201229142608788.png)

- 堆和方法区：线程共享。

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。
- Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间 。
  - 堆内存大小是可以调节的
- 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的
- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区
- 所有的对象实例以及数组都应当在运行时分配在堆上，
- 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置
- 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
- 堆，是GC 执行垃圾回收的重点区域。

![image-20201229150138013](images/image-20201229150138013.png)

==栈中的引用被弹出之后，堆中指定的对象并没有马上被回收，堆中的对象要等到垃圾回收之后，如果没有指向才消失。==

堆空间：

- jdk7: 新生区(Young/New) + 养老区(Old/Tenure) + 永久区(Perm)
- jdk8: 新生区(Young/New) + 养老区(Old/Tenure) + 元空间(Perm)

**堆空间大小的设置**

![image-20201229152411018](images/image-20201229152411018.png)

1. **设置堆空间大小参数**

-Xms  用来设置堆空间（年轻代 + 老年代）的初始化内存大小

​		-X 是jvm的运行参数

​		-ms  是memory start

-Xmx  用来设置堆空间（年轻代 + 老年代）的最大的内存大小

2. **默认堆空间大小**

初始内存大小： 物理电脑内存大小 / 64

​							最大内存大小：物理电脑内存大小 / 4

3. **手动设置： -Xms600M -Xmx600M**

   ​	开发中建议将初始堆内存和最大的堆内存设置成相同的值

4. **查看设置的参数：** 方式一： jps    /  jstat  -gc  进程id

   ​								方式二： -XX:+PrintGCDetails

==在算堆空间大小的时候，只算了一份eden区，所以会比实际结果偏小==

#### OOM

<img src="images/image-20201229155020928.png" alt="image-20201229155020928" style="zoom:67%;" />

#### **新生代与老年代**

- 存储在JVM中的Java对象可以被划分为两类：
  - 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
  - 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致
- Java堆区进一步细分的话，可以划分为年轻代 和 老年代
- 其中年轻代又可以划分为Eden空间，Survivor0空间和Survivor1空间（有时也叫做from区，to区）

![image-20201229160122798](images/image-20201229160122798.png)

下面这写参数一般不会调

![image-20201229160211371](images/image-20201229160211371.png)

- 配置新生代老年代参数比例
  - 默认: -XX:NewRatio=2, 表示新生代占1，老年代占2，新生代占整个堆的1/3
  - 可以修改-XX:NewRatio=4,表示新生代占1，老年代占4，新生代占整个堆的1/5

-  在Hostspot中，Eden空间和另外两个Survior空间缺省所占的比例是8:1:1  ==但是实际中的比例是6:1:1==  需要自己去指定 
- 几乎所有的对象都是在Eden区被new出来的
- 绝大部分的Java对象的销毁都在新生代进行了
  - 新生代中80%的对象都是“朝生夕死”的。
- 可以使用选项“-Xmn” 设置新生代的空间大小 （一般不设置，用NewRatio比例设置）
  - 这个参数一般使用默认值就可以了

#### 对象分配

> 为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配，在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。

1. new的对象先放伊甸园区。此区有大小限制。
2. 当伊甸园的空间填满之后，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC),将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。
3. 然后将伊甸园区中的剩余对象移动到幸存者0区
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区，如果没有回收，就会放到幸存者1区
5. 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。
6. 啥时候能区养老区呢？可以设置次数。默认是15次
   - 可以设置参数：  -XX:MaxTenuringThreshold=<N> 进行设置。

![image-20201229165617680](images/image-20201229165617680.png)

**常用的调优工具**

- JDK命令行
- Eclipse: Memory Analyzer Tool
- Jconsole
- VisualVM
- Jprofiler
- Java Flight Recorder
- GCViewer
- GC Easy



**总结：**

- 针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to
- 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不再永久区/原空间 收集。

#### GC

**Minor GC,Major GC,Full GC**

![image-20201229171231230](images/image-20201229171231230.png)

**年轻代GC(Minor GC)  触发机制:**

- 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引起GC。（每次Minor GC会清理年轻代的内存。）
- 因为大多数Java对象大多数都是朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
- Minor GC会引发STW，暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行。

**老年代（Major GC/ Full GC）触发机制**

- 指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。
- 出现Major GC 通常会伴随至少一次Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略夥选择过程）
  - 也就是说老年代空间不足会先尝试Minor GC。如果之后空间还是不足，则触发Major GC
- Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。
- 如果Major GC后，内存还不足，就报OOM
- Major GC 的速度一般会比Minor GC慢十倍以上

**Full GC触发机制**

1. 调用System.gc()时
2. 老年代空间不足时
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区，Survivor space0(From Space) 区向survivor space1(To Space)区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存大小小于该对象的大小。

说明：==full GC是开发或调优中尽量要避免的。这样暂时时间会短一些==

**堆空间的分代思想**

![image-20201229174148870](images/image-20201229174148870.png)

#### 内存分配策略

针对不同年龄段的对象分配原则如下所示：

- 优先分配到Eden
- 大对象直接分配到老年代
  - 尽量避免程序中出现过多的大对象
- 长期存活的对象分配到老年代
- 动态对象年龄判断
  - 如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold 中要求的年龄
- 空间分配担保
  - -XX:HandlePromotionFailure

#### 对象分配过程

> 为什么有TLAB（Thread Local Allocation Buffer）?
>
> - 堆是线程共享区域，任何线程都可以访问到堆区中的共享数据
> - 由于对象实例在堆中创建非常的频繁，因此在并发环境下从堆区划分内存空间是线程不安全的
> - 为了避免多个线程操作同一地址，需要使用枷锁等机制，进而影响分配速度。

- 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区，它包含在Eden空间内
- 多个线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将内存分配方式称之为快速分配策略。
- 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选
- 可以通过使用 -XX:UseTLAB 开启
- 一旦对象在TLAB空间的分配内存失败了，JVM就会尝试着通过加锁机制，确保数据操作的原子性，从而直接在Eden空间汇中分配内存。

#### 堆空间参数设置

官网说明：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html

![image-20201230115615992](images/image-20201230115615992.png)

![image-20201230115756063](images/image-20201230115756063.png)

- 当eden区比较大，但是survior比较小（from to）

==尽量使在from to 区域能循环15次后，再跳转如老年代，如果还没15次，就因为eden区满了，而调用Minor GC去回收到from to区域就会使分代意义弱==

- 如果eden区比较小，但是survivor比较大（from to）

YGC：触发条件eden区满的时候。YGC频率变高，STW总体时间变多。

在发生Minor GC之前，虚拟机会去检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。

- 如果大于，则此次Minor GC是安全的
- 如果小于，则虚拟机会查看-XX: HandlePromotionFailure设置值是否允许担保失败
  - 如果是true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小
    - 如果大于，则尝试进行一次Minor GC，但是这次Minor GC依然是有风险的
    - 如果小于，则改为进行一次Full GC
  - 如果为false，则进行一次Full GC

但是JDK7之后，不再进行空间分配担保了，规则变为：只要老年代的连续空间大于新生代对象总大小/历次晋升的平均大小就会进行Minor GC，否则将进行Full GC

![image-20201230143053986](images/image-20201230143053986.png)





### 面试题

#### 面试题1

> 常见的i++ 和 ++i的区别，放到字节码篇章再介绍

```java
public void add(){
        // 第1类问题
        int i1 = 10;
        i1++;

        int i2 = 10;
        ++i2;

        //第2类问题
        int i3 = 10;
        int i4 = i3++;

        int i5 = 10;
        int i6 = ++i5;

        //第3类问题
        int i7 = 10;
        i7 = i7++;

        int i8 = 10;
        i8 = ++ i8;

        // 第4类问题
        int i9 = 10;
        int i10 = i9++ + ++i9;
    }
```



#### 堆是分配对象的唯一选择吗

> 随着JIT技术与逃逸分析技术的发展，栈上分配，标量替换优化技术将会导致一些微妙的变化，所有的对象分配到堆上也不再那么绝对
>
> 如果逃逸分析后发现，一个对象并没有逃逸出去的话，那么就可能被优化成栈上的分配，无需再堆上分配。

通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上

逃逸分析的基本行为就是分析对象动态作用域:

- 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸   （使用栈上分配）
- 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方

![image-20201230135827052](images/image-20201230135827052.png)

使用逃逸分析，编译器可以对代码做如下优化：

- **栈上分配：**将堆分配转换为栈上分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。
- **同步省略：** 如果一个对象呗发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步（锁消除）
  - ![image-20201230141753002](images/image-20201230141753002.png)
- **分离对象或标量替换：**有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分可以不存储在内存，而是存储在CPU寄存器中
  - 标量：一个无法再分解成更小的数据的数据。Java中原始数据类型就是标量。聚合量：还可以分解的数据，Java中对象就是聚合量，因为他可以分解成其他聚合量和标量。

结论：开发中能使用局部变量的，就不要使用在方法外定义。







​	

































